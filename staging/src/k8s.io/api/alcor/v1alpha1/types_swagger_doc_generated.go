/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using hack/update-generated-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE. DO NOT EDIT.
var map_Affinity = map[string]string{
	"":                        "Affinity is a group of affinity scheduling rules.",
	"clusterAffinity":         "Describes cluster affinity scheduling rules for the stablemodel.",
	"stablemodelAffinity":     "Describes stablemodel affinity scheduling rules (e.g. co-locate this stablemodel in the same cluster, node, zone, etc. as some other stablemodel(s)).",
	"stablemodelAntiAffinity": "Describes stablemodel anti-affinity scheduling rules (e.g. avoid putting this stablemodel in the same cluster, node, zone, etc. as some other stablemodel(s)).",
}

func (Affinity) SwaggerDoc() map[string]string {
	return map_Affinity
}

var map_Binding = map[string]string{
	"":           "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead.",
	"objectMeta": "ObjectMeta describes the object that is being bound.",
	"target":     "Target is the object to bind to.",
}

func (Binding) SwaggerDoc() map[string]string {
	return map_Binding
}

var map_ClusterAffinity = map[string]string{
	"": "ClusterAffinity is a group of cluster affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the affinity requirements specified by this field are not met at scheduling time, the stablemodel will not be scheduled onto the cluster. If the affinity requirements specified by this field cease to be met at some point during stablemodel execution (e.g. due to an update), the system may or may not try to eventually evict the stablemodel from its cluster.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule stablemodels to clusters that satisfy the affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster matches the corresponding matchExpressions; the cluster(s) with the highest sum are the most preferred.",
}

func (ClusterAffinity) SwaggerDoc() map[string]string {
	return map_ClusterAffinity
}

var map_ClusterSelector = map[string]string{
	"":                     "ClusterSelector A cluster selector represents the union of the results of one or more label queries over a set of clusters; that is, it represents the OR of the selectors represented by the cluster selector terms.",
	"clusterSelectorTerms": "Required. A list of cluster selector terms. The terms are ORed.",
}

func (ClusterSelector) SwaggerDoc() map[string]string {
	return map_ClusterSelector
}

var map_ClusterSelectorRequirement = map[string]string{
	"":         "ClusterSelectorRequirement A cluster selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
	"key":      "The label key that the selector applies to.",
	"operator": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
	"values":   "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
}

func (ClusterSelectorRequirement) SwaggerDoc() map[string]string {
	return map_ClusterSelectorRequirement
}

var map_ClusterSelectorTerm = map[string]string{
	"":                 "ClusterSelectorTerm A null or empty cluster selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the ClusterSelectorTerm.",
	"matchExpressions": "A list of cluster selector requirements by cluster's labels.",
	"matchFields":      "A list of cluster selector requirements by cluster's fields.",
}

func (ClusterSelectorTerm) SwaggerDoc() map[string]string {
	return map_ClusterSelectorTerm
}

var map_EventRecord = map[string]string{
	"": "事件记录",
}

func (EventRecord) SwaggerDoc() map[string]string {
	return map_EventRecord
}

var map_Features = map[string]string{
	"": "特性",
}

func (Features) SwaggerDoc() map[string]string {
	return map_Features
}

var map_IPPoolList = map[string]string{
	"": "IPPoolList contains a list of IPPool",
}

func (IPPoolList) SwaggerDoc() map[string]string {
	return map_IPPoolList
}

var map_IPPoolSpec = map[string]string{
	"":                    "IPPoolSpec defines the desired state of IPPool",
	"copyFrom":            "CopyFrom an IPPool with some spec overwrited. The main target for \"copy\" is .Status.AllocatedIPs, so admin can set spec to overwrite like Route/Mask/Vlan, but not FirstIP/LastIP which can cause IP pool range changing.",
	"firstIP":             "FirstIP is the first IP of IPPool, when the pool does not start with subnet first IP",
	"lastIP":              "FirstIP is the first IP of IPPool, when the pool does not start with subnet last IP",
	"adminStatus":         "AdminStatus marks IPPool as maintained by admin",
	"deprecated":          "Deprecated marks IPPool as deprecated, it only accept release IP, no more allocate IP",
	"detect":              "Detect is a trigger will make operator do detect to find any dirty IP exists",
	"grid":                "Grid will let IPClaim and IPClaim allocate IPs in different order, enabled by default.",
	"specialClaimedQuota": "SpecialClaimedQuota limits count to create IPClaim with lb/cfs as user. Emit means no limit, 0 means not allow.",
	"route":               "Defautl route/gateway in IPPool, only for underlay scenario",
	"mask":                "Mask for IP in IPPool, e.g. IP/MASK: 10.10.10.2/23, only for underlay scenario",
	"vlan":                "Vlan for IP in IPPool, only for underlay scenario",
	"adminAssign":         "AdminAssign is a map with owner as key, with a string of IPs and IP-ranges with comma as seperator as value. IP-range likes: 10.0.0.10-20 which contains 11 IPs, and only d part of IP(a.b.c.d) is allowed to use for IP-range, which means one like 10.0.0.10-1.20 is invalid. This allows admin to assign owner of IPs in .Status.AllocatedIPs, like to - do pre-allocate IPs for ipset or ipclaim; - mark IPs as \"EXCLUDED\" or revert; - or anything to fix in .Status.AllocatedIPs.",
	"torID":               "TORID is logical ID of tor which ippool associated with. Nodes under tor must have label \"alcor.io/saishang-ipam.torID\" to indicate the torID. // lv: TODO 可用做subnetID，用于实现vpc下隔离子网",
	"startIP":             "just for backward compatibility reason, use fisrtIP in new version",
	"endIP":               "just for backward compatibility reason, use lastIP in new version",
	"disabledIP":          "just for backward compatibility reason, no longer used",
	"backend":             "just for backward compatibility reason, no longer used",
}

func (IPPoolSpec) SwaggerDoc() map[string]string {
	return map_IPPoolSpec
}

var map_IPPoolStatus = map[string]string{
	"":                   "IPPoolStatus defines the observed state of IPPool",
	"IPCount":            "IPCount is number of total available IPs in pool.",
	"AvailableCount":     "AvailableCount is number of current available IPs in pool.",
	"Allocated":          "AllocatedIPs is map of allocated IPs.",
	"Status":             "Status is status of IPPool.",
	"LastApplied":        "LastApplied is what applied in last time to IPPool.",
	"Message":            "Message is operator processing message about IPPool.",
	"Migrated":           "Whether this IPPool has migrated from old one.",
	"oldAllocatedIPs":    "just for backward compatibility reason, no longer used",
	"oldAvailableCount":  "just for backward compatibility reason, no longer used",
	"oldIPCount":         "just for backward compatibility reason, no longer used",
	"oldStatus":          "just for backward compatibility reason, no longer used",
	"lastAppliedStartIP": "just for backward compatibility reason, no longer used",
	"lastAppliedEndIP":   "just for backward compatibility reason, no longer used",
}

func (IPPoolStatus) SwaggerDoc() map[string]string {
	return map_IPPoolStatus
}

var map_IPSetList = map[string]string{
	"": "IPSetList contains a list of IPSet",
}

func (IPSetList) SwaggerDoc() map[string]string {
	return map_IPSetList
}

var map_IPSetSpec = map[string]string{
	"":           "IPSetSpec defines the desired state of IPSet",
	"replicas":   "Number of IPs to claim. Should not less than replicas of deployment or statefulset.",
	"pool":       "From which IPPool IPSet is going to claim IP from. Can be omited for overlay scenario.",
	"vni":        "For VNI case, only for overlay scenario.",
	"sync":       "Deprecated, ignored.",
	"deprecated": "Deprecated, ignored.",
}

func (IPSetSpec) SwaggerDoc() map[string]string {
	return map_IPSetSpec
}

var map_IPSetStatus = map[string]string{
	"": "IPSetStatus defines the observed state of IPSet",
}

func (IPSetStatus) SwaggerDoc() map[string]string {
	return map_IPSetStatus
}

var map_IPStatus = map[string]string{
	"": "IPC状态",
}

func (IPStatus) SwaggerDoc() map[string]string {
	return map_IPStatus
}

var map_NetworkConfig = map[string]string{
	"": "网络申请",
}

func (NetworkConfig) SwaggerDoc() map[string]string {
	return map_NetworkConfig
}

var map_PVCStatus = map[string]string{
	"": "PVC状态",
}

func (PVCStatus) SwaggerDoc() map[string]string {
	return map_PVCStatus
}

var map_PodStatus = map[string]string{
	"": "Pod状态",
}

func (PodStatus) SwaggerDoc() map[string]string {
	return map_PodStatus
}

var map_PreferredSchedulingTerm = map[string]string{
	"":           "PreferredSchedulingTerm An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
	"weight":     "Weight associated with matching the corresponding clusterSelectorTerm, in the range 1-100.",
	"preference": "A cluster selector term, associated with the corresponding weight.",
}

func (PreferredSchedulingTerm) SwaggerDoc() map[string]string {
	return map_PreferredSchedulingTerm
}

var map_ResizeResource = map[string]string{
	"": "ResizeResource",
}

func (ResizeResource) SwaggerDoc() map[string]string {
	return map_ResizeResource
}

var map_RollingUpdateStableModelStrategy = map[string]string{
	"":          "RollingUpdateStableModelStrategy is used to communicate parameter for RollingUpdateStableModelStrategyType.",
	"partition": "Partition indicates the ordinal at which the StableModel should be partitioned.",
}

func (RollingUpdateStableModelStrategy) SwaggerDoc() map[string]string {
	return map_RollingUpdateStableModelStrategy
}

var map_StableModel = map[string]string{
	"":         "StableModel is the Scheme for the stableModel API.",
	"metadata": "Standard object's metadata.",
	"spec":     "Spec defines the specification of the desired behavior of the ReplicaSet.",
	"status":   "Status is the most recently observed status of the StableModel. This data may be out of date by some window of time. Populated by the system. Read-only.",
}

func (StableModel) SwaggerDoc() map[string]string {
	return map_StableModel
}

var map_StableModelAffinity = map[string]string{
	"": "StableModelAffinity is a group of inter worklaod affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the affinity requirements specified by this field are not met at scheduling time, the stablemodel will not be scheduled onto the cluster. If the affinity requirements specified by this field cease to be met at some point during stablemodel execution (e.g. due to a stablemodel label update), the system may or may not try to eventually evict the stablemodel from its cluster. When there are multiple elements, the lists of cluster corresponding to each stablemodelAffinityTerm are intersected, i.e. all terms must be satisfied.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule stablemodels to clusters that satisfy the affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster has stablemodels which matches the corresponding stablemodelAffinityTerm; the cluster(s) with the highest sum are the most preferred.",
}

func (StableModelAffinity) SwaggerDoc() map[string]string {
	return map_StableModelAffinity
}

var map_StableModelAffinityTerm = map[string]string{
	"":              "StableModelAffinityTerm Defines a set of stablemodels (namely those matching the labelSelector relative to the given namespace(s)) that this stablemodel should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a cluster whose value of the label with key <topologyKey> matches that of any cluster on which a cluster of the set of clusters is running",
	"labelSelector": "A label query over a set of resources, in this case stablemodels.",
	"namespaces":    "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this stablemodel's namespace\"",
	"topologyKey":   "This stablemodel should be co-located (affinity) or not co-located (anti-affinity) with the stablemodels matching the labelSelector in the specified namespaces, where co-located is defined as running on a cluster whose value of the label with key topologyKey matches that of any cluster on which any of the selected stablemodels is running. Empty topologyKey is not allowed.",
}

func (StableModelAffinityTerm) SwaggerDoc() map[string]string {
	return map_StableModelAffinityTerm
}

var map_StableModelAntiAffinity = map[string]string{
	"": "StableModelAntiAffinity is a group of inter worklaod anti affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the anti-affinity requirements specified by this field are not met at scheduling time, the stablemodel will not be scheduled onto the cluster. If the anti-affinity requirements specified by this field cease to be met at some point during stablemodel execution (e.g. due to a worklaod label update), the system may or may not try to eventually evict the stablemodel from its cluster. When there are multiple elements, the lists of clusters corresponding to each stablemodelAffinityTerm are intersected, i.e. all terms must be satisfied.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule stablemodels to clusters that satisfy the anti-affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster has stablemodels which matches the corresponding stablemodelAffinityTerm; the stablemodel(s) with the highest sum are the most preferred.",
}

func (StableModelAntiAffinity) SwaggerDoc() map[string]string {
	return map_StableModelAntiAffinity
}

var map_StableModelCondition = map[string]string{
	"":                   "StableModelCondition describes the state of a stablemodel at a certain point.",
	"type":               "Type of replica set condition.",
	"status":             "Status of the condition, one of True, False, Unknown.",
	"lastTransitionTime": "The last time the condition transitioned from one status to another.",
	"reason":             "The reason for the condition's last transition.",
	"message":            "A human readable message indicating details about the transition.",
}

func (StableModelCondition) SwaggerDoc() map[string]string {
	return map_StableModelCondition
}

var map_StableModelList = map[string]string{
	"":         "StableModelList is a collection of ReplicaSets.",
	"metadata": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
	"items":    "List of StableModels.",
}

func (StableModelList) SwaggerDoc() map[string]string {
	return map_StableModelList
}

var map_StableModelSpec = map[string]string{
	"":                          "StableModelSpec is the specification of a StableModel.",
	"selector":                  "Selector is a label query over pods that should match the replica count. Label keys and values that must match in order to be controlled by this replica set. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
	"podTemplate":               "Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/stableModels/controllers/replicationcontroller#pod-template",
	"clusterSelector":           "ClusterSelector is a selector which must be true for the stableModel to fit on a cluster. Selector which must match a cluster's labels for the stableModel to be scheduled on that cluster.",
	"clusterName":               "ClusterName is a request to schedule this stableModel onto a specific cluster. If it is non-empty, the scheduler simply schedules this stableModel onto that cluster, assuming that it fits resource requirements.",
	"affinity":                  "If specified, the stableModel's scheduling constraints",
	"tolerations":               "If specified, the stablemodel's tolerations.",
	"schedulerName":             "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
	"topologySpreadConstraints": "TopologySpreadConstraints describes how a group of stablemodels ought to spread across topology domains. Scheduler will schedule stablemodels in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
}

func (StableModelSpec) SwaggerDoc() map[string]string {
	return map_StableModelSpec
}

var map_StableModelStatus = map[string]string{
	"":           "StableModelStatus defines the observed state of StableModel",
	"conditions": "Represents the latest available observations of a replica set's current state.",
}

func (StableModelStatus) SwaggerDoc() map[string]string {
	return map_StableModelStatus
}

var map_StableModelUpdateStrategy = map[string]string{
	"type":          "Type indicates the type of the StableModelUpdateStrategyType. Default is RollingUpdate.",
	"rollingUpdate": "RollingUpdate is used to communicate parameters when Type is RollingUpdateStableModelStrategyType.",
}

func (StableModelUpdateStrategy) SwaggerDoc() map[string]string {
	return map_StableModelUpdateStrategy
}

var map_WeightedStableModelAffinityTerm = map[string]string{
	"":                        "WeightedStableModelAffinityTerm The weights of all of the matched WeightedStableModelAffinityTerm fields are added per-cluster to find the most preferred cluster(s)",
	"weight":                  "weight associated with matching the corresponding stablemodelAffinityTerm, in the range 1-100.",
	"stablemodelAffinityTerm": "Required. A stablemodel affinity term, associated with the corresponding weight.",
}

func (WeightedStableModelAffinityTerm) SwaggerDoc() map[string]string {
	return map_WeightedStableModelAffinityTerm
}

// AUTO-GENERATED FUNCTIONS END HERE
