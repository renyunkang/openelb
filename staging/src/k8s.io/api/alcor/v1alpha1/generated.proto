/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package k8s.io.api.alcor.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "k8s.io/api/alcor/v1alpha1";

// Affinity is a group of affinity scheduling rules.
message Affinity {
  // Describes cluster affinity scheduling rules for the stablemodel.
  // +optional
  optional ClusterAffinity clusterAffinity = 1;

  // Describes stablemodel affinity scheduling rules (e.g. co-locate this stablemodel in the same cluster, node, zone, etc. as some other stablemodel(s)).
  // +optional
  optional StableModelAffinity stablemodelAffinity = 2;

  // Describes stablemodel anti-affinity scheduling rules (e.g. avoid putting this stablemodel in the same cluster, node, zone, etc. as some other stablemodel(s)).
  // +optional
  optional StableModelAntiAffinity stablemodelAntiAffinity = 3;
}

// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
// Deprecated in 1.7, please use the bindings subresource of pods instead.
message Binding {
  // ObjectMeta describes the object that is being bound.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta objectMeta = 1;

  // Target is the object to bind to.
  optional k8s.io.api.core.v1.ObjectReference target = 2;
}

// ClusterAffinity is a group of cluster affinity scheduling rules.
message ClusterAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the stablemodel will not be scheduled onto the cluster.
  // If the affinity requirements specified by this field cease to be met
  // at some point during stablemodel execution (e.g. due to an update), the system
  // may or may not try to eventually evict the stablemodel from its cluster.
  // +optional
  optional ClusterSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule stablemodels to clusters that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster matches the corresponding matchExpressions; the
  // cluster(s) with the highest sum are the most preferred.
  // +optional
  repeated PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// ClusterSelector A cluster selector represents the union of the results of one or more label queries
// over a set of clusters; that is, it represents the OR of the selectors represented
// by the cluster selector terms.
message ClusterSelector {
  // Required. A list of cluster selector terms. The terms are ORed.
  repeated ClusterSelectorTerm clusterSelectorTerms = 1;
}

// ClusterSelectorRequirement A cluster selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
message ClusterSelectorRequirement {
  // The label key that the selector applies to.
  optional string key = 1;

  // Represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  optional string operator = 2;

  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. If the operator is Gt or Lt, the values
  // array must have a single element, which will be interpreted as an integer.
  // This array is replaced during a strategic merge patch.
  // +optional
  repeated string values = 3;
}

// ClusterSelectorTerm A null or empty cluster selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the ClusterSelectorTerm.
message ClusterSelectorTerm {
  // A list of cluster selector requirements by cluster's labels.
  // +optional
  repeated ClusterSelectorRequirement matchExpressions = 1;

  // A list of cluster selector requirements by cluster's fields.
  // +optional
  repeated ClusterSelectorRequirement matchFields = 2;
}

// 事件记录
message EventRecord {
  optional string eventType = 1;

  optional string createTime = 2;

  optional string lastMessage = 3;
}

// 特性
message Features {
  optional bool rebootPod = 1;

  optional bool forceDriftPod = 2;

  optional bool pausePod = 3;

  optional bool driftPod = 4;

  optional string rebootPodTimestamp = 5;

  optional string forceDriftPodTimestamp = 6;

  optional ResizeResource preResizePod = 7;

  optional ResizeResource resizePod = 8;

  optional bool delayUpdatePod = 9;
}

message IPPool {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional IPPoolSpec spec = 2;

  optional IPPoolStatus status = 3;
}

// IPPoolList contains a list of IPPool
message IPPoolList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated IPPool items = 2;
}

// IPPoolSpec defines the desired state of IPPool
message IPPoolSpec {
  // CopyFrom an IPPool with some spec overwrited. The main target for "copy" is
  // .Status.AllocatedIPs, so admin can set spec to overwrite like
  // Route/Mask/Vlan, but not FirstIP/LastIP which can cause IP pool range changing.
  optional string copyFrom = 1;

  // FirstIP is the first IP of IPPool, when the pool does not start with subnet first IP
  optional string firstIP = 2;

  // FirstIP is the first IP of IPPool, when the pool does not start with subnet last IP
  optional string lastIP = 3;

  // AdminStatus marks IPPool as maintained by admin
  optional bool adminStatus = 4;

  // Deprecated marks IPPool as deprecated, it only accept release IP, no more allocate IP
  optional bool deprecated = 5;

  // Detect is a trigger will make operator do detect to find any dirty IP exists
  optional bool detect = 6;

  // Grid will let IPClaim and IPClaim allocate IPs in different order, enabled by default.
  optional bool grid = 7;

  // SpecialClaimedQuota limits count to create IPClaim with lb/cfs as user. Emit means no limit, 0 means not allow.
  map<string, int64> specialClaimedQuota = 8;

  // Defautl route/gateway in IPPool, only for underlay scenario
  optional string route = 9;

  // Mask for IP in IPPool, e.g. IP/MASK: 10.10.10.2/23, only for underlay scenario
  optional int64 mask = 10;

  // Vlan for IP in IPPool, only for underlay scenario
  optional int64 vlan = 11;

  // AdminAssign is a map with owner as key, with a string of IPs and IP-ranges with comma as seperator as value.
  // IP-range likes: 10.0.0.10-20 which contains 11 IPs, and only d part of IP(a.b.c.d) is
  // allowed to use for IP-range, which means one like 10.0.0.10-1.20 is invalid.
  // This allows admin to assign owner of IPs in .Status.AllocatedIPs, like to
  // - do pre-allocate IPs for ipset or ipclaim;
  // - mark IPs as "EXCLUDED" or revert;
  // - or anything to fix in .Status.AllocatedIPs.
  map<string, string> adminAssign = 12;

  // TORID is logical ID of tor which ippool associated with. Nodes under tor must have label
  // "alcor.io/saishang-ipam.torID" to indicate the torID. // lv: TODO 可用做subnetID，用于实现vpc下隔离子网
  optional string torID = 13;

  // just for backward compatibility reason, use fisrtIP in new version
  optional string startIP = 14;

  // just for backward compatibility reason, use lastIP in new version
  optional string endIP = 15;

  // just for backward compatibility reason, no longer used
  repeated string disabledIP = 16;

  // just for backward compatibility reason, no longer used
  optional string backend = 17;
}

// IPPoolStatus defines the observed state of IPPool
message IPPoolStatus {
  // IPCount is number of total available IPs in pool.
  optional int64 IPCount = 1;

  // AvailableCount is number of current available IPs in pool.
  optional int64 AvailableCount = 2;

  // AllocatedIPs is map of allocated IPs.
  map<string, string> Allocated = 3;

  // Status is status of IPPool.
  optional string Status = 4;

  // LastApplied is what applied in last time to IPPool.
  map<string, string> LastApplied = 5;

  // Message is operator processing message about IPPool.
  optional string Message = 6;

  map<string, string> BlockedIPs = 7;

  map<string, int64> SpecialClaimedUsage = 8;

  // Whether this IPPool has migrated from old one.
  optional bool Migrated = 9;

  // just for backward compatibility reason, no longer used
  map<string, string> oldAllocatedIPs = 10;

  // just for backward compatibility reason, no longer used
  optional int64 oldAvailableCount = 11;

  // just for backward compatibility reason, no longer used
  optional int64 oldIPCount = 12;

  // just for backward compatibility reason, no longer used
  optional string oldStatus = 13;

  // just for backward compatibility reason, no longer used
  optional string lastAppliedStartIP = 14;

  // just for backward compatibility reason, no longer used
  optional string lastAppliedEndIP = 15;
}

message IPSet {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional IPSetSpec spec = 2;

  optional IPSetStatus status = 3;
}

// IPSetList contains a list of IPSet
message IPSetList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated IPSet items = 2;
}

// IPSetSpec defines the desired state of IPSet
message IPSetSpec {
  // Number of IPs to claim. Should not less than replicas of deployment or statefulset.
  optional int64 replicas = 1;

  // From which IPPool IPSet is going to claim IP from. Can be omited for overlay scenario.
  optional string pool = 2;

  // For VNI case, only for overlay scenario.
  optional bool vni = 3;

  // Deprecated, ignored.
  optional bool sync = 4;

  // Deprecated, ignored.
  optional bool deprecated = 5;
}

// IPSetStatus defines the observed state of IPSet
message IPSetStatus {
  optional string Status = 1;

  optional string Message = 2;

  repeated string IPs = 3;

  repeated string DirtyIPs = 4;

  map<string, string> IPMap = 5;

  map<string, string> LastApplied = 6;

  optional string CallbackReason = 7;
}

// IPC状态
message IPStatus {
  optional string name = 1;

  optional string status = 2;

  optional string ip = 3;

  optional string backend = 4;
}

// 网络申请
message NetworkConfig {
  optional string iP = 1;

  optional string nIC = 2;

  optional string nICMAC = 3;

  optional string host = 4;

  optional string pool = 5;

  optional string mbps = 6;

  optional bool vNI = 7;
}

message NetworkRequest {
  optional string name = 1;

  optional string networkClassName = 2;

  optional NetworkConfig config = 3;
}

// PVC状态
message PVCStatus {
  optional string name = 1;

  optional string status = 2;

  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
}

// Pod状态
message PodStatus {
  optional string name = 1;

  optional string status = 2;
}

// PreferredSchedulingTerm An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
message PreferredSchedulingTerm {
  // Weight associated with matching the corresponding clusterSelectorTerm, in the range 1-100.
  optional int32 weight = 1;

  // A cluster selector term, associated with the corresponding weight.
  optional ClusterSelectorTerm preference = 2;
}

// ResizeResource
message ResizeResource {
  optional ResourceLimit podResource = 1;

  map<string, ResourceLimit> containersResource = 2;
}

message ResourceLimit {
  optional k8s.io.apimachinery.pkg.api.resource.Quantity cpu = 1;

  optional k8s.io.apimachinery.pkg.api.resource.Quantity memory = 2;
}

// RollingUpdateStableModelStrategy is used to communicate parameter for RollingUpdateStableModelStrategyType.
message RollingUpdateStableModelStrategy {
  // Partition indicates the ordinal at which the StableModel should be
  // partitioned.
  optional int32 partition = 1;
}

// StableModel is the Scheme for the stableModel API.
message StableModel {
  // Standard object's metadata.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta objectMeta = 1;

  // Spec defines the specification of the desired behavior of the ReplicaSet.
  // +optional
  optional StableModelSpec spec = 2;

  // Status is the most recently observed status of the StableModel.
  // This data may be out of date by some window of time.
  // Populated by the system.
  // Read-only.
  // +optional
  optional StableModelStatus status = 3;
}

// StableModelAffinity is a group of inter worklaod affinity scheduling rules.
message StableModelAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the stablemodel will not be scheduled onto the cluster.
  // If the affinity requirements specified by this field cease to be met
  // at some point during stablemodel execution (e.g. due to a stablemodel label update), the
  // system may or may not try to eventually evict the stablemodel from its cluster.
  // When there are multiple elements, the lists of cluster corresponding to each
  // stablemodelAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated StableModelAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule stablemodels to clusters that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster has stablemodels which matches the corresponding stablemodelAffinityTerm; the
  // cluster(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedStableModelAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// StableModelAffinityTerm Defines a set of stablemodels (namely those matching the labelSelector
// relative to the given namespace(s)) that this stablemodel should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a cluster whose value of
// the label with key <topologyKey> matches that of any cluster on which
// a cluster of the set of clusters is running
message StableModelAffinityTerm {
  // A label query over a set of resources, in this case stablemodels.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

  // namespaces specifies which namespaces the labelSelector applies to (matches against);
  // null or empty list means "this stablemodel's namespace"
  // +optional
  repeated string namespaces = 2;

  // This stablemodel should be co-located (affinity) or not co-located (anti-affinity) with the stablemodels matching
  // the labelSelector in the specified namespaces, where co-located is defined as running on a cluster
  // whose value of the label with key topologyKey matches that of any cluster on which any of the
  // selected stablemodels is running.
  // Empty topologyKey is not allowed.
  optional string topologyKey = 3;
}

// StableModelAntiAffinity is a group of inter worklaod anti affinity scheduling rules.
message StableModelAntiAffinity {
  // If the anti-affinity requirements specified by this field are not met at
  // scheduling time, the stablemodel will not be scheduled onto the cluster.
  // If the anti-affinity requirements specified by this field cease to be met
  // at some point during stablemodel execution (e.g. due to a worklaod label update), the
  // system may or may not try to eventually evict the stablemodel from its cluster.
  // When there are multiple elements, the lists of clusters corresponding to each
  // stablemodelAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated StableModelAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule stablemodels to clusters that satisfy
  // the anti-affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling anti-affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster has stablemodels which matches the corresponding stablemodelAffinityTerm; the
  // stablemodel(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedStableModelAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// StableModelCondition describes the state of a stablemodel at a certain point.
message StableModelCondition {
  // Type of replica set condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // The last time the condition transitioned from one status to another.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  // +optional
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  // +optional
  optional string message = 5;
}

// StableModelList is a collection of ReplicaSets.
message StableModelList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta listMeta = 1;

  // List of StableModels.
  repeated StableModel items = 2;
}

// StableModelSpec is the specification of a StableModel.
message StableModelSpec {
  // Selector is a label query over pods that should match the replica count.
  // Label keys and values that must match in order to be controlled by this replica set.
  // It must match the pod template's labels.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;

  optional string mode = 2;

  // Template is the object that describes the pod that will be created if
  // insufficient replicas are detected.
  // More info: https://kubernetes.io/docs/concepts/stableModels/controllers/replicationcontroller#pod-template
  // +optional
  optional k8s.io.api.core.v1.PodTemplateSpec podTemplate = 3;

  optional NetworkRequest network = 4;

  repeated StorageRequest storage = 5;

  optional Features feature = 6;

  optional string nodeName = 7;

  optional string resizePhase = 12;

  // ClusterSelector is a selector which must be true for the stableModel to fit on a cluster.
  // Selector which must match a cluster's labels for the stableModel to be scheduled on that cluster.
  // +optional
  map<string, string> clusterSelector = 8;

  // ClusterName is a request to schedule this stableModel onto a specific cluster. If it is non-empty,
  // the scheduler simply schedules this stableModel onto that cluster, assuming that it fits resource
  // requirements.
  // +optional
  optional string clusterName = 9;

  // If specified, the stableModel's scheduling constraints
  // +optional
  optional Affinity affinity = 10;

  // If specified, the stablemodel's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 13;

  // If specified, the pod will be dispatched by specified scheduler.
  // If not specified, the pod will be dispatched by default scheduler.
  // +optional
  optional string schedulerName = 11;

  // TopologySpreadConstraints describes how a group of stablemodels ought to spread across topology
  // domains. Scheduler will schedule stablemodels in a way which abides by the constraints.
  // All topologySpreadConstraints are ANDed.
  // +optional
  // +patchMergeKey=topologyKey
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=topologyKey
  // +listMapKey=whenUnsatisfiable
  repeated k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 14;
}

// StableModelStatus defines the observed state of StableModel
message StableModelStatus {
  optional string phase = 1;

  optional PodStatus podRef = 2;

  optional IPStatus ipRef = 3;

  repeated PVCStatus pvcRefs = 4;

  repeated EventRecord events = 5;

  // Represents the latest available observations of a replica set's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated StableModelCondition conditions = 6;

  optional string resizePhase = 7;

  optional string rebootPodTimestamp = 8;

  optional string forceDriftPodTimestamp = 9;

  optional bool driftPod = 10;

  optional string nodeName = 11;
}

message StableModelUpdateStrategy {
  // Type indicates the type of the StableModelUpdateStrategyType.
  // Default is RollingUpdate.
  // +optional
  optional string type = 1;

  // RollingUpdate is used to communicate parameters when Type is RollingUpdateStableModelStrategyType.
  // +optional
  optional RollingUpdateStableModelStrategy rollingUpdate = 2;
}

message StorageRequest {
  optional string name = 1;

  optional k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
}

// WeightedStableModelAffinityTerm The weights of all of the matched WeightedStableModelAffinityTerm fields are added per-cluster to find the most preferred cluster(s)
message WeightedStableModelAffinityTerm {
  // weight associated with matching the corresponding stablemodelAffinityTerm,
  // in the range 1-100.
  optional int32 weight = 1;

  // Required. A stablemodel affinity term, associated with the corresponding weight.
  optional StableModelAffinityTerm stablemodelAffinityTerm = 2;
}

