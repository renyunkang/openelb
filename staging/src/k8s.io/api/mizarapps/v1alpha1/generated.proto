/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package k8s.io.api.mizarapps.v1alpha1;

import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "k8s.io/api/mizarapps/v1alpha1";

// Affinity is a group of affinity scheduling rules.
message Affinity {
  // Describes cluster affinity scheduling rules for the workload.
  // +optional
  optional ClusterAffinity clusterAffinity = 1;

  // Describes workload affinity scheduling rules (e.g. co-locate this workload in the same cluster, node, zone, etc. as some other workload(s)).
  // +optional
  optional WorkloadAffinity workloadAffinity = 2;

  // Describes workload anti-affinity scheduling rules (e.g. avoid putting this workload in the same cluster, node, zone, etc. as some other workload(s)).
  // +optional
  optional WorkloadAntiAffinity workloadAntiAffinity = 3;
}

// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
// Deprecated in 1.7, please use the bindings subresource of pods instead.
message Binding {
  // ObjectMeta describes the object that is being bound.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta objectMeta = 1;

  // Target is the object to bind to.
  optional k8s.io.api.core.v1.ObjectReference target = 2;
}

// CRDResourceHook
message CRDResourceHook {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional CRDResourceHookSpec spec = 2;

  optional CRDResourceHookStatus status = 3;
}

// CRDResourceHookList is a list of GlobalQuota resources.
message CRDResourceHookList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated CRDResourceHook items = 2;
}

// CRDResourceHookSpec
message CRDResourceHookSpec {
  // Hook
  optional ResourceCalculateHook hook = 1;

  // CRDReference
  optional k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind crdReference = 2;
}

message CRDResourceHookStatus {
  optional bool active = 1;
}

// ClusterAffinity is a group of cluster affinity scheduling rules.
message ClusterAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the workload will not be scheduled onto the cluster.
  // If the affinity requirements specified by this field cease to be met
  // at some point during workload execution (e.g. due to an update), the system
  // may or may not try to eventually evict the workload from its cluster.
  // +optional
  optional ClusterSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule workloads to clusters that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster matches the corresponding matchExpressions; the
  // cluster(s) with the highest sum are the most preferred.
  // +optional
  repeated PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// GlobalQuota sets aggregate quota restrictions enforced per namespace
message ClusterQuota {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the desired quota.
  // +optional
  optional k8s.io.api.core.v1.ClusterResourceQuotaSpec spec = 2;

  // Status defines the actual enforced quota and its current usage.
  // +optional
  optional k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
}

// GlobalQuotaList is a list of GlobalQuota resources.
message ClusterQuotaList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated ClusterQuota items = 2;
}

// ClusterSelector A cluster selector represents the union of the results of one or more label queries
// over a set of clusters; that is, it represents the OR of the selectors represented
// by the cluster selector terms.
message ClusterSelector {
  // Required. A list of cluster selector terms. The terms are ORed.
  repeated ClusterSelectorTerm clusterSelectorTerms = 1;
}

// ClusterSelectorRequirement A cluster selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
message ClusterSelectorRequirement {
  // The label key that the selector applies to.
  optional string key = 1;

  // Represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  optional string operator = 2;

  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. If the operator is Gt or Lt, the values
  // array must have a single element, which will be interpreted as an integer.
  // This array is replaced during a strategic merge patch.
  // +optional
  repeated string values = 3;
}

// ClusterSelectorTerm A null or empty cluster selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the ClusterSelectorTerm.
message ClusterSelectorTerm {
  // A list of cluster selector requirements by cluster's labels.
  // +optional
  repeated ClusterSelectorRequirement matchExpressions = 1;

  // A list of cluster selector requirements by cluster's fields.
  // +optional
  repeated ClusterSelectorRequirement matchFields = 2;
}

// GlobalQuota sets aggregate quota restrictions enforced per namespace
message GlobalQuota {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the desired quota.
  // +optional
  optional k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;

  // Status defines the actual enforced quota and its current usage.
  // +optional
  optional k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
}

// GlobalQuotaList is a list of GlobalQuota resources.
message GlobalQuotaList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated GlobalQuota items = 2;
}

// K8SObject
message K8SObject {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionKind groupVersionKind = 1;

  // Name
  optional string name = 2;
}

message K8SObjectStatus {
  optional k8s.io.api.core.v1.ObjectReference reference = 1;

  // Scheduled specifies whether the resource is scheduled.
  optional bool scheduled = 2;

  // Ready specifies whether the resource is ready.
  optional bool ready = 3;

  // Deleted
  optional bool deleted = 4;

  // Replicas
  optional int32 replica = 5;

  // ReadyReplicas
  optional int32 readyReplicas = 6;
}

// Location
message Location {
  // NextCluster is a request to schedule this workload onto a specific cluster.
  // If NextCluster match affinity, then unpackage workload in this cluster. Otherwise, set NextCluster to empty and schedule
  // this workload to sub cluster.
  // +optional
  optional string nextCluster = 1;
}

// PreferredSchedulingTerm An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
message PreferredSchedulingTerm {
  // Weight associated with matching the corresponding clusterSelectorTerm, in the range 1-100.
  optional int32 weight = 1;

  // A cluster selector term, associated with the corresponding weight.
  optional ClusterSelectorTerm preference = 2;
}

// ResourceCalculateHook
message ResourceCalculateHook {
  // `url` gives the location of the webhook, in standard URL form
  // (`scheme://host:port/path`). Exactly one of `url` or `service`
  // must be specified.
  //
  // The `host` should not refer to a service running in the cluster; use
  // the `service` field instead. The host might be resolved via external
  // DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
  // in-cluster DNS as that would be a layering violation). `host` may
  // also be an IP address.
  //
  // Please note that using `localhost` or `127.0.0.1` as a `host` is
  // risky unless you take great care to run this webhook on all hosts
  // which run an apiserver which might need to make calls to this
  // webhook. Such installs are likely to be non-portable, i.e., not easy
  // to turn up in a new cluster.
  //
  // The scheme must be "https"; the URL must begin with "https://".
  //
  // A path is optional, and if present may be any string permissible in
  // a URL. You may use the path to pass an arbitrary string to the
  // webhook, for example, a cluster identifier.
  //
  // Attempting to use a user or basic auth e.g. "user:password@" is not
  // allowed. Fragments ("#...") and query parameters ("?...") are not
  // allowed, either.
  //
  // +optional
  optional string url = 1;

  // `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
  // If unspecified, system trust roots on the apiserver are used.
  // +optional
  optional string caBase64 = 2;

  // CertBase64
  optional string certBase64 = 3;

  // KeyBase64
  optional string keyBase64 = 4;
}

// RollingUpdateWorkloadStrategy is used to communicate parameter for RollingUpdateWorkloadStrategyType.
message RollingUpdateWorkloadStrategy {
  // Partition indicates the ordinal at which the Workload should be
  // partitioned.
  optional int32 partition = 1;
}

// WeightedWorkloadAffinityTerm The weights of all of the matched WeightedWorkloadAffinityTerm fields are added per-cluster to find the most preferred cluster(s)
message WeightedWorkloadAffinityTerm {
  // weight associated with matching the corresponding workloadAffinityTerm,
  // in the range 1-100.
  optional int32 weight = 1;

  // Required. A workload affinity term, associated with the corresponding weight.
  optional WorkloadAffinityTerm workloadAffinityTerm = 2;
}

// Workload is the Scheme for the workload API.
message Workload {
  // Standard object's metadata.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  // Spec defines the specification of the desired behavior of the ReplicaSet.
  // +optional
  optional WorkloadSpec spec = 2;

  // Status is the most recently observed status of the Workload.
  // This data may be out of date by some window of time.
  // Populated by the system.
  // Read-only.
  // +optional
  optional WorkloadStatus status = 3;
}

// WorkloadAffinity is a group of inter worklaod affinity scheduling rules.
message WorkloadAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the workload will not be scheduled onto the cluster.
  // If the affinity requirements specified by this field cease to be met
  // at some point during workload execution (e.g. due to a workload label update), the
  // system may or may not try to eventually evict the workload from its cluster.
  // When there are multiple elements, the lists of cluster corresponding to each
  // workloadAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated WorkloadAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule workloads to clusters that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster has workloads which matches the corresponding workloadAffinityTerm; the
  // cluster(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedWorkloadAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// WorkloadAffinityTerm Defines a set of workloads (namely those matching the labelSelector
// relative to the given namespace(s)) that this workload should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a cluster whose value of
// the label with key <topologyKey> matches that of any cluster on which
// a cluster of the set of clusters is running
message WorkloadAffinityTerm {
  // A label query over a set of resources, in this case workloads.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

  // namespaces specifies which namespaces the labelSelector applies to (matches against);
  // null or empty list means "this workload's namespace"
  // +optional
  repeated string namespaces = 2;

  // This workload should be co-located (affinity) or not co-located (anti-affinity) with the workloads matching
  // the labelSelector in the specified namespaces, where co-located is defined as running on a cluster
  // whose value of the label with key topologyKey matches that of any cluster on which any of the
  // selected workloads is running.
  // Empty topologyKey is not allowed.
  optional string topologyKey = 3;

  // A label query over the set of namespaces that the term applies to.
  // The term is applied to the union of the namespaces selected by this field
  // and the ones listed in the namespaces field.
  // null selector and null or empty namespaces list means "this pod's namespace".
  // An empty selector ({}) matches all namespaces.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
}

// WorkloadAntiAffinity is a group of inter worklaod anti affinity scheduling rules.
message WorkloadAntiAffinity {
  // If the anti-affinity requirements specified by this field are not met at
  // scheduling time, the workload will not be scheduled onto the cluster.
  // If the anti-affinity requirements specified by this field cease to be met
  // at some point during workload execution (e.g. due to a worklaod label update), the
  // system may or may not try to eventually evict the workload from its cluster.
  // When there are multiple elements, the lists of clusters corresponding to each
  // workloadAffinityTerm are intersected, i.e. all terms must be satisfied.
  // +optional
  repeated WorkloadAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

  // The scheduler will prefer to schedule workloads to clusters that satisfy
  // the anti-affinity expressions specified by this field, but it may choose
  // a cluster that violates one or more of the expressions. The cluster that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each cluster that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling anti-affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the cluster has workloads which matches the corresponding workloadAffinityTerm; the
  // workload(s) with the highest sum are the most preferred.
  // +optional
  repeated WeightedWorkloadAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
}

// WorkloadCondition describes the state of a workload at a certain point.
message WorkloadCondition {
  // Type of replica set condition.
  optional string type = 1;

  // Status of the condition, one of True, False, Unknown.
  optional string status = 2;

  // The last time the condition transitioned from one status to another.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

  // The reason for the condition's last transition.
  // +optional
  optional string reason = 4;

  // A human readable message indicating details about the transition.
  // +optional
  optional string message = 5;
}

// WorkloadList is a collection of ReplicaSets.
message WorkloadList {
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  // List of Workloads.
  repeated Workload items = 2;
}

// WorkloadSpec is the specification of a Workload.
message WorkloadSpec {
  // Types describe the type of Workload, could be stateless|stateful|stable
  // +optional
  optional string type = 1;

  // K8SObjects containers k8s object raw definitons if Type is k8s-object.
  repeated k8s.io.apimachinery.pkg.runtime.RawExtension k8sObjects = 2;

  // scheudler use DestAffinity to choose cluster and set location, kubelet-for-cluster reconcile workload
  // if location.NextCluster equal self cluster name.
  // +optional
  optional Location location = 3;

  // If specified, the workload's scheduling constraints
  // +optional
  optional Affinity destAffinity = 4;

  // If specified, the pod will be dispatched by specified scheduler.
  // If not specified, the pod will be dispatched by default scheduler.
  // +optional
  optional string schedulerName = 5;

  // CheckFilters special objects
  repeated K8SObject checkFilters = 6;
}

// WorkloadStatus represents the current status of a Workload.
message WorkloadStatus {
  // Phase is one of Running, Pending, Unknown, Terminating
  optional string phase = 1;

  // observedGeneration is the most recent generation observed for this Workload. It corresponds to the
  // StatefulSet's generation, which is updated on mutation by the API Server.
  // +optional
  optional int64 observedGeneration = 2;

  // Represents the latest available observations of a replica set's current state.
  // +optional
  // +patchMergeKey=type
  // +patchStrategy=merge
  repeated WorkloadCondition conditions = 3;

  // K8SObjectStatus record the related resources created by this workload.
  repeated K8SObjectStatus k8sObjectStatus = 4;

  // AllocatedResources
  map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;

  // Region
  optional string region = 6;

  // PhysicalZone
  repeated string physicalZone = 7;

  // LogicZone
  repeated string logicZone = 8;
}

message WorkloadUpdateStrategy {
  // Type indicates the type of the WorkloadUpdateStrategyType.
  // Default is RollingUpdate.
  // +optional
  optional string type = 1;

  // RollingUpdate is used to communicate parameters when Type is RollingUpdateWorkloadStrategyType.
  // +optional
  optional RollingUpdateWorkloadStrategy rollingUpdate = 2;
}

