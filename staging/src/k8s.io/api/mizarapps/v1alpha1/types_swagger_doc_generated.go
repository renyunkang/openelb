/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using hack/update-generated-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE. DO NOT EDIT.
var map_Affinity = map[string]string{
	"":                     "Affinity is a group of affinity scheduling rules.",
	"clusterAffinity":      "Describes cluster affinity scheduling rules for the workload.",
	"workloadAffinity":     "Describes workload affinity scheduling rules (e.g. co-locate this workload in the same cluster, node, zone, etc. as some other workload(s)).",
	"workloadAntiAffinity": "Describes workload anti-affinity scheduling rules (e.g. avoid putting this workload in the same cluster, node, zone, etc. as some other workload(s)).",
}

func (Affinity) SwaggerDoc() map[string]string {
	return map_Affinity
}

var map_Binding = map[string]string{
	"":           "Binding ties one object to another; for example, a pod is bound to a node by a scheduler. Deprecated in 1.7, please use the bindings subresource of pods instead.",
	"objectMeta": "ObjectMeta describes the object that is being bound.",
	"target":     "Target is the object to bind to.",
}

func (Binding) SwaggerDoc() map[string]string {
	return map_Binding
}

var map_CRDResourceHook = map[string]string{
	"": "CRDResourceHook",
}

func (CRDResourceHook) SwaggerDoc() map[string]string {
	return map_CRDResourceHook
}

var map_CRDResourceHookList = map[string]string{
	"": "CRDResourceHookList is a list of GlobalQuota resources.",
}

func (CRDResourceHookList) SwaggerDoc() map[string]string {
	return map_CRDResourceHookList
}

var map_CRDResourceHookSpec = map[string]string{
	"":             "CRDResourceHookSpec",
	"hook":         "Hook",
	"crdReference": "CRDReference",
}

func (CRDResourceHookSpec) SwaggerDoc() map[string]string {
	return map_CRDResourceHookSpec
}

var map_ClusterAffinity = map[string]string{
	"": "ClusterAffinity is a group of cluster affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the affinity requirements specified by this field are not met at scheduling time, the workload will not be scheduled onto the cluster. If the affinity requirements specified by this field cease to be met at some point during workload execution (e.g. due to an update), the system may or may not try to eventually evict the workload from its cluster.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule workloads to clusters that satisfy the affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster matches the corresponding matchExpressions; the cluster(s) with the highest sum are the most preferred.",
}

func (ClusterAffinity) SwaggerDoc() map[string]string {
	return map_ClusterAffinity
}

var map_ClusterQuota = map[string]string{
	"":       "GlobalQuota sets aggregate quota restrictions enforced per namespace",
	"spec":   "Spec defines the desired quota.",
	"status": "Status defines the actual enforced quota and its current usage.",
}

func (ClusterQuota) SwaggerDoc() map[string]string {
	return map_ClusterQuota
}

var map_ClusterQuotaList = map[string]string{
	"": "GlobalQuotaList is a list of GlobalQuota resources.",
}

func (ClusterQuotaList) SwaggerDoc() map[string]string {
	return map_ClusterQuotaList
}

var map_ClusterSelector = map[string]string{
	"":                     "ClusterSelector A cluster selector represents the union of the results of one or more label queries over a set of clusters; that is, it represents the OR of the selectors represented by the cluster selector terms.",
	"clusterSelectorTerms": "Required. A list of cluster selector terms. The terms are ORed.",
}

func (ClusterSelector) SwaggerDoc() map[string]string {
	return map_ClusterSelector
}

var map_ClusterSelectorRequirement = map[string]string{
	"":         "ClusterSelectorRequirement A cluster selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
	"key":      "The label key that the selector applies to.",
	"operator": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
	"values":   "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
}

func (ClusterSelectorRequirement) SwaggerDoc() map[string]string {
	return map_ClusterSelectorRequirement
}

var map_ClusterSelectorTerm = map[string]string{
	"":                 "ClusterSelectorTerm A null or empty cluster selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the ClusterSelectorTerm.",
	"matchExpressions": "A list of cluster selector requirements by cluster's labels.",
	"matchFields":      "A list of cluster selector requirements by cluster's fields.",
}

func (ClusterSelectorTerm) SwaggerDoc() map[string]string {
	return map_ClusterSelectorTerm
}

var map_GlobalQuota = map[string]string{
	"":       "GlobalQuota sets aggregate quota restrictions enforced per namespace",
	"spec":   "Spec defines the desired quota.",
	"status": "Status defines the actual enforced quota and its current usage.",
}

func (GlobalQuota) SwaggerDoc() map[string]string {
	return map_GlobalQuota
}

var map_GlobalQuotaList = map[string]string{
	"": "GlobalQuotaList is a list of GlobalQuota resources.",
}

func (GlobalQuotaList) SwaggerDoc() map[string]string {
	return map_GlobalQuotaList
}

var map_K8SObject = map[string]string{
	"":     "K8SObject",
	"name": "Name",
}

func (K8SObject) SwaggerDoc() map[string]string {
	return map_K8SObject
}

var map_K8SObjectStatus = map[string]string{
	"scheduled":     "Scheduled specifies whether the resource is scheduled.",
	"ready":         "Ready specifies whether the resource is ready.",
	"deleted":       "Deleted",
	"replica":       "Replicas",
	"readyReplicas": "ReadyReplicas",
}

func (K8SObjectStatus) SwaggerDoc() map[string]string {
	return map_K8SObjectStatus
}

var map_Location = map[string]string{
	"":            "Location",
	"nextCluster": "NextCluster is a request to schedule this workload onto a specific cluster. If NextCluster match affinity, then unpackage workload in this cluster. Otherwise, set NextCluster to empty and schedule this workload to sub cluster.",
}

func (Location) SwaggerDoc() map[string]string {
	return map_Location
}

var map_PreferredSchedulingTerm = map[string]string{
	"":           "PreferredSchedulingTerm An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
	"weight":     "Weight associated with matching the corresponding clusterSelectorTerm, in the range 1-100.",
	"preference": "A cluster selector term, associated with the corresponding weight.",
}

func (PreferredSchedulingTerm) SwaggerDoc() map[string]string {
	return map_PreferredSchedulingTerm
}

var map_ResourceCalculateHook = map[string]string{
	"":           "ResourceCalculateHook",
	"url":        "`url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",
	"caBase64":   "`caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.",
	"certBase64": "CertBase64",
	"keyBase64":  "KeyBase64",
}

func (ResourceCalculateHook) SwaggerDoc() map[string]string {
	return map_ResourceCalculateHook
}

var map_RollingUpdateWorkloadStrategy = map[string]string{
	"":          "RollingUpdateWorkloadStrategy is used to communicate parameter for RollingUpdateWorkloadStrategyType.",
	"partition": "Partition indicates the ordinal at which the Workload should be partitioned.",
}

func (RollingUpdateWorkloadStrategy) SwaggerDoc() map[string]string {
	return map_RollingUpdateWorkloadStrategy
}

var map_WeightedWorkloadAffinityTerm = map[string]string{
	"":                     "WeightedWorkloadAffinityTerm The weights of all of the matched WeightedWorkloadAffinityTerm fields are added per-cluster to find the most preferred cluster(s)",
	"weight":               "weight associated with matching the corresponding workloadAffinityTerm, in the range 1-100.",
	"workloadAffinityTerm": "Required. A workload affinity term, associated with the corresponding weight.",
}

func (WeightedWorkloadAffinityTerm) SwaggerDoc() map[string]string {
	return map_WeightedWorkloadAffinityTerm
}

var map_Workload = map[string]string{
	"":         "Workload is the Scheme for the workload API.",
	"metadata": "Standard object's metadata.",
	"spec":     "Spec defines the specification of the desired behavior of the ReplicaSet.",
	"status":   "Status is the most recently observed status of the Workload. This data may be out of date by some window of time. Populated by the system. Read-only.",
}

func (Workload) SwaggerDoc() map[string]string {
	return map_Workload
}

var map_WorkloadAffinity = map[string]string{
	"": "WorkloadAffinity is a group of inter worklaod affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the affinity requirements specified by this field are not met at scheduling time, the workload will not be scheduled onto the cluster. If the affinity requirements specified by this field cease to be met at some point during workload execution (e.g. due to a workload label update), the system may or may not try to eventually evict the workload from its cluster. When there are multiple elements, the lists of cluster corresponding to each workloadAffinityTerm are intersected, i.e. all terms must be satisfied.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule workloads to clusters that satisfy the affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster has workloads which matches the corresponding workloadAffinityTerm; the cluster(s) with the highest sum are the most preferred.",
}

func (WorkloadAffinity) SwaggerDoc() map[string]string {
	return map_WorkloadAffinity
}

var map_WorkloadAffinityTerm = map[string]string{
	"":                  "WorkloadAffinityTerm Defines a set of workloads (namely those matching the labelSelector relative to the given namespace(s)) that this workload should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a cluster whose value of the label with key <topologyKey> matches that of any cluster on which a cluster of the set of clusters is running",
	"labelSelector":     "A label query over a set of resources, in this case workloads.",
	"namespaces":        "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this workload's namespace\"",
	"topologyKey":       "This workload should be co-located (affinity) or not co-located (anti-affinity) with the workloads matching the labelSelector in the specified namespaces, where co-located is defined as running on a cluster whose value of the label with key topologyKey matches that of any cluster on which any of the selected workloads is running. Empty topologyKey is not allowed.",
	"namespaceSelector": "A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \"this pod's namespace\". An empty selector ({}) matches all namespaces.",
}

func (WorkloadAffinityTerm) SwaggerDoc() map[string]string {
	return map_WorkloadAffinityTerm
}

var map_WorkloadAntiAffinity = map[string]string{
	"": "WorkloadAntiAffinity is a group of inter worklaod anti affinity scheduling rules.",
	"requiredDuringSchedulingIgnoredDuringExecution":  "If the anti-affinity requirements specified by this field are not met at scheduling time, the workload will not be scheduled onto the cluster. If the anti-affinity requirements specified by this field cease to be met at some point during workload execution (e.g. due to a worklaod label update), the system may or may not try to eventually evict the workload from its cluster. When there are multiple elements, the lists of clusters corresponding to each workloadAffinityTerm are intersected, i.e. all terms must be satisfied.",
	"preferredDuringSchedulingIgnoredDuringExecution": "The scheduler will prefer to schedule workloads to clusters that satisfy the anti-affinity expressions specified by this field, but it may choose a cluster that violates one or more of the expressions. The cluster that is most preferred is the one with the greatest sum of weights, i.e. for each cluster that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the cluster has workloads which matches the corresponding workloadAffinityTerm; the workload(s) with the highest sum are the most preferred.",
}

func (WorkloadAntiAffinity) SwaggerDoc() map[string]string {
	return map_WorkloadAntiAffinity
}

var map_WorkloadCondition = map[string]string{
	"":                   "WorkloadCondition describes the state of a workload at a certain point.",
	"type":               "Type of replica set condition.",
	"status":             "Status of the condition, one of True, False, Unknown.",
	"lastTransitionTime": "The last time the condition transitioned from one status to another.",
	"reason":             "The reason for the condition's last transition.",
	"message":            "A human readable message indicating details about the transition.",
}

func (WorkloadCondition) SwaggerDoc() map[string]string {
	return map_WorkloadCondition
}

var map_WorkloadList = map[string]string{
	"":         "WorkloadList is a collection of ReplicaSets.",
	"metadata": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
	"items":    "List of Workloads.",
}

func (WorkloadList) SwaggerDoc() map[string]string {
	return map_WorkloadList
}

var map_WorkloadSpec = map[string]string{
	"":              "WorkloadSpec is the specification of a Workload.",
	"type":          "Types describe the type of Workload, could be stateless|stateful|stable",
	"k8sObjects":    "K8SObjects containers k8s object raw definitons if Type is k8s-object.",
	"location":      "scheudler use DestAffinity to choose cluster and set location, kubelet-for-cluster reconcile workload if location.NextCluster equal self cluster name.",
	"destAffinity":  "If specified, the workload's scheduling constraints",
	"schedulerName": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
	"checkFilters":  "CheckFilters special objects",
}

func (WorkloadSpec) SwaggerDoc() map[string]string {
	return map_WorkloadSpec
}

var map_WorkloadStatus = map[string]string{
	"":                   "WorkloadStatus represents the current status of a Workload.",
	"phase":              "Phase is one of Running, Pending, Unknown, Terminating",
	"observedGeneration": "observedGeneration is the most recent generation observed for this Workload. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.",
	"conditions":         "Represents the latest available observations of a replica set's current state.",
	"k8sObjectStatus":    "K8SObjectStatus record the related resources created by this workload.",
	"allocatedResources": "AllocatedResources",
	"region":             "Region",
	"physicalZone":       "PhysicalZone",
	"logicZone":          "LogicZone",
}

func (WorkloadStatus) SwaggerDoc() map[string]string {
	return map_WorkloadStatus
}

var map_WorkloadUpdateStrategy = map[string]string{
	"type":          "Type indicates the type of the WorkloadUpdateStrategyType. Default is RollingUpdate.",
	"rollingUpdate": "RollingUpdate is used to communicate parameters when Type is RollingUpdateWorkloadStrategyType.",
}

func (WorkloadUpdateStrategy) SwaggerDoc() map[string]string {
	return map_WorkloadUpdateStrategy
}

// AUTO-GENERATED FUNCTIONS END HERE
